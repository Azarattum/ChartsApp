class GL {    /**     * Creates GL object.     * @param {Element} canvas Canvas element.     * @param {ShadersProgram} program Vertex & Fragment shaders program.     */    constructor(canvas, program = null) {                this.canvas = canvas;        this.gl = canvas.getContext("webgl", {            alpha: false,            premultipliedAlpha: false        }) || canvas.getContext("experimental-webgl", {            alpha: false,            premultipliedAlpha: false        }) || canvas.getContext("moz-webgl", {            alpha: false,            premultipliedAlpha: false        }) || canvas.getContext("webkit-3d", {            alpha: false,            premultipliedAlpha: false        });        this.currentProgram = 0;        this.programsBuffer = [];        if (program != null) {            this.newProgram(program);        }        this.attributes = new Proxy([], {            set: (obj, name, value) => {                const program = this.programsBuffer[this.currentProgram];                let attribute = program.attributeBuffer[program.currentStack].find(x => x.name == name);                let type = program.attributes[name];                if (type == undefined) {                    console.warn(new Error("Attribute " + name + " does not exist in shader program!"));                    return;                }                if (attribute != undefined) {                    attribute.update(value);                } else {                    program.attributeBuffer[program.currentStack].push(                        new Attrubute(this.gl, program.program, type, name, value)                    );                }                return true;            },            get: (obj, name) => {                const program = this.programsBuffer[this.currentProgram];                let attribute = program.attributeBuffer[program.currentStack].find(x => x.name == name);                if (attribute == undefined) return undefined;                return attribute.value;            }        });        this.uniforms = new Proxy([], {            set: (obj, name, value) => {                const program = this.programsBuffer[this.currentProgram];                let uniform = program.uniformBuffer.find(x => x.name == name);                let type = program.uniforms[name];                if (type == undefined) {                    console.warn(new Error("Uniform " + name + " does not exist in shader program!"));                    return;                }                if (uniform != undefined) {                    uniform.update(value);                } else {                    program.uniformBuffer.push(                        new Uniform(this.gl, program.program, type, name, value)                    );                }                return true;            },            get: (obj, name) => {                const program = this.programsBuffer[this.currentProgram];                let uniform = program.uniformBuffer.find(x => x.name == name);                if (uniform == undefined) return undefined;                return uniform.value;            }        });        this.gl.clearColor(0., 0., 0., 0.);        this.gl.enable(this.gl.BLEND);        this.gl.disable(this.gl.DEPTH_TEST)        this.gl.disable(this.gl.CULL_FACE)        this.gl.blendFuncSeparate(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA,            this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);        this.resize();    }        /**     * Sets current stack.     */    set stack(value) {        const program = this.programsBuffer[this.currentProgram];        if (value >= 0 && value < program.attributeBuffer.length)            program.currentStack = value;        for (const attribute of program.attributeBuffer[program.currentStack]) {            attribute.bind();        }        if (program.indexBuffer[program.currentStack]) {            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, program.indexBuffer[program.currentStack]);        }    }    /**     * Returns current stack id.     */    get stack() {        const program = this.programsBuffer[this.currentProgram];        return program.currentStack;    }    /**     * Sets current program as current.     */    set program(value) {        if (value >= 0 && value < this.programsBuffer.length)            this.currentProgram = value;        this.programsBuffer[this.currentProgram].use();    }    /**     * Returns current program id.     */    get program() {        return this.currentProgram;    }    set background(color) {        if (!color) return;        this.clearColor = color.toArray();        this.gl.clearColor(this.clearColor[0], this.clearColor[1], this.clearColor[2], this.clearColor[3]);    }    set indices(indices) {        this.programsBuffer[this.currentProgram].indices = indices;    }            /**     * Creates a new shders program.     */    newProgram(program) {        program.attach(this.gl);        this.programsBuffer.push(program);        this.currentProgram = this.programsBuffer.length - 1;        return this.currentProgram;    }    /**     * Creates a new stack.     */    newStack() {        const program = this.programsBuffer[this.currentProgram];        if (program.attributeBuffer[program.currentStack].length == 0) {            return program.currentStack;        }        program.attributeBuffer.push([]);        program.currentStack = program.attributeBuffer.length - 1;        return program.currentStack;    }    resize(width = this.canvas.clientWidth, height = this.canvas.clientHeight) {        this.viewport = {            width: width * window.devicePixelRatio,            height: height * window.devicePixelRatio        }        this.canvas.width = this.viewport.width;        this.canvas.height = this.viewport.height;        this.gl.viewport(0, 0, this.viewport.width, this.viewport.height);    }    clear() {        this.gl.clear(this.gl.COLOR_BUFFER_BIT);    }        drawStrip(count, offset = 0) {        this.gl.drawArrays(this.gl.LINE_STRIP, offset, count - offset);    }    drawTriangles(count, offset = 0) {        this.gl.drawArrays(this.gl.TRIANGLES, offset, count - offset);    }    drawPoints(count, offset = 0) {        this.gl.drawArrays(this.gl.POINTS, offset, count - offset);    }    drawShape(count, offset = 0) {        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, offset, count - offset);    }    drawCircle(count, offset = 0) {        this.gl.drawArrays(this.gl.TRIANGLE_FAN, offset, count - offset);    }    drawElements(count, offset = 0) {        this.gl.drawElements(this.gl.TRIANGLES, count - offset, this.gl.UNSIGNED_SHORT, offset * 2);    }        }class Attrubute {    constructor(gl, program, type, name, value) {        this.gl = gl;        this.type = type;        this.buffer = gl.createBuffer();        this.name = name;        this.value = value;        this.program = program;        switch (type) {            case gl.FLOAT:                this.pointerSize = 1;                this.pointerType = gl.FLOAT;                break;            case gl.FLOAT_VEC2:                this.pointerSize = 2;                this.pointerType = gl.FLOAT;                break;            case gl.FLOAT_VEC3:                this.pointerSize = 3;                this.pointerType = gl.FLOAT;                break;            case gl.FLOAT_VEC4:                this.pointerSize = 4;                this.pointerType = gl.FLOAT;                break;            case gl.FLOAT_MAT2:                this.pointerSize = 2;                this.pointerType = gl.FLOAT;                break;            case gl.FLOAT_MAT3:                this.pointerSize = 3;                this.pointerType = gl.FLOAT;                break;            case gl.FLOAT_MAT4:                this.pointerSize = 4;                this.pointerType = gl.FLOAT;                break;            default:                throw new Error("Unknown attribute type " + type + "!");        }        this.bind();        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(value), gl.STATIC_DRAW);    }    update(value) {        this.value = value;        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(value), this.gl.STATIC_DRAW);    }    bind() {        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);        let location = this.gl.getAttribLocation(this.program, this.name);        this.gl.vertexAttribPointer(location, this.pointerSize, this.pointerType, false, 0, 0);        this.gl.enableVertexAttribArray(location);    }}class Uniform {    constructor(gl, program, type, name, value) {        this.gl = gl;        this.name = name;        this.value = value;        this.location = gl.getUniformLocation(program, name);        switch (type) {            case gl.FLOAT:                this.function = this.gl.uniform1fv;                break;            case gl.FLOAT_VEC2:                this.function = gl.uniform2fv;                break;            case gl.FLOAT_VEC3:                this.function = gl.uniform3fv;                break;            case gl.FLOAT_VEC4:                this.function = gl.uniform4fv;                break;            case gl.FLOAT_MAT2:                this.function = (location, value) => {                    gl.uniformMatrix2fv(location, false, value);                };                break;            case gl.FLOAT_MAT3:                this.function = (location, value) => {                    gl.uniformMatrix3fv(location, false, value);                };                break;            case gl.FLOAT_MAT4:                this.function = (location, value) => {                    gl.uniformMatrix4fv(location, false, value);                };                break;            case gl.INT:                this.function = gl.uniform1iv;                break;            case gl.INT_VEC2:                this.function = gl.uniform2iv;                break;            case gl.INT_VEC3:                this.function = gl.uniform3iv;                break;            case gl.INT_VEC4:                this.function = gl.uniform4iv;                break;            case gl.SAMPLER_2D:                this.function = gl.uniform1iv;                break;            case gl.SAMPLER_CUBE:                this.function = gl.uniform1iv;                break;            case gl.BOOL:                this.function = gl.uniform1iv;                break;            case gl.BOOL_VEC2:                this.function = gl.uniform2iv;                break;            case gl.BOOL_VEC3:                this.function = gl.uniform3iv;                break;            case gl.BOOL_VEC4:                this.function = gl.uniform4iv;                break;            default:                throw new Error("Unknown uniform type " + type + "!");        }        this.update(value);    }    update(value) {        this.value = value;        if (!Array.isArray(value) && !(value instanceof Float32Array)) {            value = [value];        }        this.function.call(this.gl, this.location, value);    }}class Shader {    constructor(code, type) {        this.code = code;        this.type = type;        this.shader = null;        this.gl = null;        this.program = null;        this._changed = false;    }    set variables(variables) {                let offset = 0;        do {            const repeat = /^\s*\/\*\/\s*repeat\s+([0-9a-zA-Z]+)\s*\/\*\/\r?\n([^\n]*)/m;            const result = this.code.substr(offset).match(repeat);            if (!result) break;            const length = result[0].length;            const count = +parse(result[1], false);            const statement = result[2];            if (!Number.isInteger(count)) {                throw new Error("Compilation failed! Iterator must be an integer!")            }            let compiled = [];            for (let i = 0; i < count; i++) {                variables.i = i;                compiled.push(parse(statement, true));            }            delete variables.i;            this.code = this.code.slice(0, result.index + offset + 1) +                compiled.join("\n") + this.code.slice(result.index + offset + length);            offset = result.index + 1;        }        while (true)                this.code = parse(this.code, true);        function parse(string, wrapped) {            for (const variable in variables) {                let exp = variable;                if (wrapped) {                    exp = "\\/\\*\\/\\s*" + exp + "\\s*\\/\\*\\/";                }                string = string.replace(new RegExp(exp, "g"), variables[variable]);            }            return string;        }    }    attach(gl, program) {        this.gl = gl;        this.program = program;        this.compile();        gl.attachShader(program, this.shader);    }    update() {        if (this.gl == null || this, program == null) {            throw new Error("Shader is not attached!");        }        this.compile();        this.gl.linkProgram(this.program);    }    compile() {        if (this.shader != null && !this._changed) return;        if (this.gl == null) {            throw new Error("Shader is not attached!");        }        this.shader = this.gl.createShader(this.type);        this.gl.shaderSource(this.shader, this.code);        this.gl.compileShader(this.shader);    }    static get types() {        return Object.freeze({            "VERTEX": WebGLRenderingContext.VERTEX_SHADER,            "FRAGMENT": WebGLRenderingContext.FRAGMENT_SHADER        });    }}class ShadersProgram {    constructor(vertex, fragment) {        this.attributes = [];        this.uniforms = [];        this.vertex = vertex;        this.fragment = fragment;        this.gl = null;        this.program = null;        this.uniformBuffer = [];        this.attributeBuffer = [            []        ];        this.indexBuffer = [];        this.currentStack = 0;    }    set indices(indices) {        if (this.indexBuffer.length <= this.currentStack) {            this.indexBuffer[this.currentStack] = this.gl.createBuffer();            this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer[this.currentStack]);        }        if (!(indices instanceof Uint16Array)) {            indices = new Uint16Array(indices);        }        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indices, this.gl.STATIC_DRAW);    }    attach(gl) {        if (this.gl == gl) return;        this.gl = gl;        this.program = gl.createProgram();        this.vertex.attach(gl, this.program);        this.fragment.attach(gl, this.program);        gl.linkProgram(this.program);        this.attributes = [];        let attributesCount = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);        for (let i = 0; i < attributesCount; i++) {            let attribute = gl.getActiveAttrib(this.program, i);            this.attributes[attribute.name] = attribute.type;        }        this.uniforms = [];        let uniformsCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);        for (let i = 0; i < uniformsCount; i++) {            let uniform = gl.getActiveUniform(this.program, i);            this.uniforms[uniform.name.replace(/[[][0-9]+]$/g, "")] = uniform.type;        }    }    use() {        if (this.gl == null) {            throw new Error("Program is not attached!");        }        this.gl.useProgram(this.program);    }}class Color {    constructor(param1, param2, param3, param4) {        this.color = {            r: 0,            g: 0,            b: 0,            a: 255        };        if (param1 instanceof Color) {            this.color.r = param1.r;            this.color.g = param1.g;            this.color.b = param1.b;            this.color.a = param1.a;            return;        }        if (param1 === undefined) {            return;        }        if (Number.isFinite(param1) && Number.isFinite(param2) &&            Number.isFinite(param3)) {            this.r = param1;            this.g = param2;            this.b = param3;            if (Number.isFinite(param4)) {                this.a = param4;            } else {                this.a = 255;            }            return;        }        let colors;        try {            colors = param1.match(/^#?([0-9a-f]{3}[0-9a-f]?);?$/i)[1];            if (colors) {                this.r = parseInt(colors.charAt(0), 16) * 0x11;                this.g = parseInt(colors.charAt(1), 16) * 0x11;                this.b = parseInt(colors.charAt(2), 16) * 0x11;                if (colors.charAt(3)) {                    this.a = parseInt(colors.charAt(3), 16) * 0x11;                } else {                    this.a = 255;                }                return;            }        } catch {}        try {            colors = param1.match(/^#?([0-9a-f]{6}([0-9a-f]{2})?);?$/i)[1];            if (colors) {                this.r = parseInt(colors.substr(0, 2), 16);                this.g = parseInt(colors.substr(2, 2), 16);                this.b = parseInt(colors.substr(4, 2), 16);                if (colors.substr(6, 2)) {                    this.a = parseInt(colors.substr(6, 2), 16);                } else {                    this.a = 255;                }                return;            }        } catch {}        try {            colors = param1.match(/^rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*(\d+)\s*)?\);?$/i);            if (colors) {                this.r = colors[1];                this.g = colors[2];                this.b = colors[3];                if (colors[5]) {                    this.a = colors[5];                } else {                    this.a = 255;                }                return;            }        } catch {}        try {            colors = param1.match(/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*(\d+)\s*)?;?$/i);            if (colors) {                this.r = colors[1];                this.g = colors[2];                this.b = colors[3];                if (colors[5]) {                    this.a = colors[5];                } else {                    this.a = 255;                }                return;            }        } catch {}    }    get r() {        return this.color.r;    }    set r(value) {        this.color.r = this.normalize(value);    }    get g() {        return this.color.g;    }    set g(value) {        this.color.g = this.normalize(value);    }    get b() {        return this.color.b;    }    set b(value) {        this.color.b = this.normalize(value);    }    get a() {        return this.color.a;    }    set a(value) {        this.color.a = this.normalize(value);    }    red(value) {        let color = new Color(this);        color.r = value;        return color;    }    green(value) {        let color = new Color(this);        color.g = value;        return color;    }    blue(value) {        let color = new Color(this);        color.b = value;        return color;    }    alpha(value) {        let color = new Color(this);        color.a = value;        return color;    }    normalize(value) {        if (+value > 255)            return 255;        else if (+value < 0)            return 0;        else             return Math.round(+value);    }    toString() {        return "rgba(" + this.r + "," + this.g + "," + this.b + "," + (this.a / 255) + ")";    }    toHex() {        function toHex(number) {            const hex = number.toString(16);            return hex.length == 1 ? "0" + hex : hex;        }        return "#" + toHex(this.r) + toHex(this.g) + toHex(this.b) + toHex(this.a);    }    toArray(includeAlpha = true) {        if (!includeAlpha) {            return new Float32Array([this.r / 255., this.g / 255., this.b / 255.]);        } else {            return new Float32Array([this.r / 255., this.g / 255., this.b / 255., this.a / 255.]);        }    }}class Point {    constructor(x = 0, y = 0) {        this.position = {            x: x,            y: y        };    }    get x() {        return this.position.x;    }    set x(value) {        this.position.x = value;    }    get y() {        return this.position.y;    }    set y(value) {        this.position.y = value;    }    normal() {        return new Point(-this.y, this.x);    }    invert() {        return new Point(-this.x, -this.y);    }    normalize() {        let length = this.length;        return new Point(this.x / length, this.y / length);    }    expand(value) {        return new Point(this.x * value, this.y * value);    }    add(point) {        return new Point(this.x + point.x, this.y + point.y);    }    subtract(point) {        return new Point(this.x - point.x, this.y - point.y);    }    dot(point) {        return this.x * point.x + this.y * point.y;    }    get length() {        return Math.sqrt(this.x * this.x + this.y * this.y);    }    toString() {        return this.x + "," + this.y;    }}class AnimationObject {    /**     * Creates an object for animating properties.     * @param {Number} startProperty Property value at the start of the animation.     * @param {Number} endProperty Property value at the end of the animation.     * @param {Number} duration How long the animation will be in milliseconds.     */    constructor(startProperty, endProperty = startProperty, duration = 0) {        this.startTime = Date.now();        this.duration = duration;        this.startProperty = startProperty;        this.endProperty = endProperty;        this.modified = false;    }    /**     * Sets new animation goal from the current state.     * @param {Number} endProperty New end property value.     * @param {Number} duration How long the animation will be in milliseconds.     */    set(endProperty, duration = this.duration) {        const currentProperty = this.get();        if (endProperty.toString() == currentProperty.toString() ||            endProperty.toString() == this.endProperty.toString()) {            return;        }        this.startProperty = currentProperty;        this.startTime = Date.now();        this.duration = duration;        this.endProperty = endProperty;        this.modified = true;    }    /**     * Returns the property value based on the past time.     */    get() {        let timePast = Date.now() - this.startTime;        if (timePast >= this.duration) return this.endProperty;        if (typeof this.startProperty == "number") {            return this.interpolate(this.startProperty, this.endProperty, (timePast / this.duration));        } else if (Array.isArray(this.startProperty)) {            const progress = (timePast / this.duration);            let animated = [];            for (let i = 0; i < this.startProperty.length; i++) {                animated.push(                    this.interpolate(this.startProperty[i], this.endProperty[i], progress)                );            }            return animated;        } else if (this.startProperty instanceof Color) {            const progress = (timePast / this.duration);            return new Color(                this.interpolate(this.startProperty.r, this.endProperty.r, progress),                this.interpolate(this.startProperty.g, this.endProperty.g, progress),                this.interpolate(this.startProperty.b, this.endProperty.b, progress),                this.interpolate(this.startProperty.a, this.endProperty.a, progress)            );        } else if (this.startProperty instanceof Point) {            const progress = (timePast / this.duration);            return new Point(                this.interpolate(this.startProperty.x, this.endProperty.x, progress),                this.interpolate(this.startProperty.y, this.endProperty.y, progress)            );        }    }    interpolate(min, max, progress) {        return min + (progress * (max - min));    }    /**     * Returns whether animation is in progress or not.     */    get inProgress() {        if ((Date.now() - this.startTime) > this.duration) return false;        return true;    }}console.debug = function () {    if (!console.debugging) return;    console.log.apply(this, arguments);};document.addEventListener("touchstart", function () {}, true);/** * This class represents a chart. */class Chart {    /**     * Creates a chart object.     * @param {Object} source Source JSON string, object or filename to create a chart.     */    constructor(source) {                /**Returns the contained graph objects.*/        this.graphs = [];                                if (typeof source === "string") {                        try {                source = JSON.parse(source);            } catch {                throw new Error("Source is not a valid JSON object!");            }        }        if (Array.isArray(source)) {            throw new Error("Array is not allowed! Use \"Chart.array\" instead.");        }        if (!(                typeof source === "object" &&                typeof source.colors === "object" &&                typeof source.columns === "object" &&                typeof source.names === "object" &&                typeof source.types === "object"            )) {            throw new Error("Wrong source format!");        }                        this.stacked = !!source.stacked;        this.percentage = !!source.percentage;        this.scaled = !!source.y_scaled;        const shift = typeof source.columns[0][0] == "string";        this.xAxis = source.columns[0];        if (shift) this.xAxis.shift();        this.size = new Point(-Number.MAX_SAFE_INTEGER, -Number.MAX_SAFE_INTEGER);        this.offsets = new Point(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);        for (let i = 1; i < source.columns.length; i++) {            let yAxis = source.columns[i];            if (shift) yAxis.shift();            const id = Object.keys(source.names)[i - 1];            const color = new Color(source.colors[id]);            const name = source.names[id];            const type = source.types[id];            const graph = new Graph(this.xAxis, yAxis, color, name, type, this.percentage);            if (graph.size.x > this.size.x) {                this.size.x = graph.size.x;            }            if (graph.size.y > this.size.y) {                this.size.y = graph.size.y;            }            if (graph.minX < this.offsets.x) {                this.offsets.x = graph.minX;            }            if (graph.minY < this.offsets.y) {                this.offsets.y = graph.minY;            }            this.graphs.push(graph);        }        if (this.percentage) {            this.size.y = 100;            this.offsets.y = 0;        }        this.graphs = this.graphs.sort(function (a, b) {            return b.maxY - a.maxY        });        this.type = this.graphs[0].type;        if (this.type == "bar") this.stacked = true;                if (!this.scaled) {            this.graphs.forEach(x => x.calculateVertices(this.size, this.offsets));        } else {            this.graphs.forEach(x => x.calculateVertices(x.size, new Point(x.minX, x.minY)));        }                console.debug("Chart created", this);    }    /**     * Returns an array of chart objects.     * @param {Array} source Source JSON string, array or filename to create charts.     * @returns {Chart[]} An array of chart objects.     */    static array(source) {                        if (typeof source === "string") {                        try {                source = JSON.parse(source);            } catch {                throw new Error("Source is not a valid JSON object!");            }        }        if (!Array.isArray(source)) {            throw new Error("Source is not an array! Use \"new Chart\" if it is a chart source.");        }                let charts = [];        for (const chart of source) {            charts.push(new Chart(chart));        }        console.debug("Charts array parsed", charts);        return charts;    }}/** * This class represents a graph. */class Graph {    /**     * Creates a graph object.     * @param {Object} source Source object to create a graph.     */    constructor(xAxis, yAxis, color, name, type) {                /**Graph color.*/        this.color = color;        /**Graph name.*/        this.name = name;        /**Graph type.*/        this.type = type;        /**Top values.*/        this.maxX = -Number.MAX_SAFE_INTEGER;        this.minX = Number.MAX_SAFE_INTEGER;        this.maxY = -Number.MAX_SAFE_INTEGER;        this.minY = Number.MAX_SAFE_INTEGER;        /**Graph points.*/        this.points = [];        /**Graph normalized points.*/        this.vertices = [];        for (let i = 0; i < xAxis.length; i++) {            const x = xAxis[i];            const y = yAxis[i];            if (x > this.maxX) this.maxX = x;            if (x < this.minX) this.minX = x;            if (y > this.maxY) this.maxY = y;            if (y < this.minY) this.minY = y;            this.points.push(new Point(x, y));            this.vertices.push(new Point(x, y));        }        /**Graph size.*/        this.size = new Point(this.maxX - this.minX, this.maxY - this.minY);                console.debug("Graph created", this);    }    /**     * Count of points in the graph.     */    get length() {        return this.points.length;    }    calculateVertices(maxSize, minSize) {        this.vertices.forEach((point) => {            point.x = (point.x - minSize.x) / maxSize.x * 2 - 1;            point.y = (point.y - minSize.y) / maxSize.y * 2 - 1;        });    }}/** * This class is used to create path points for drawing from graphs. */class Path {    constructor(points) {        this.points = points;        this.indices = new Uint16Array(points.length * 6);        this.vertices = [];    }    get length() {        return (this.points.length - 1) * 6;    }}/** * This class exteds Path class to path areas. */class PathArea extends Path {    constructor(points, graphs) {        super(points);                this.sums = [];        this.uppers = [];        this.bases = [];                        points.forEach((point, index) => {            this.vertices.push(point.x, point.y, point.x, -1);        });                points.forEach((point, index) => {            this.bases.push(0, 1);        });                const thisIndex = graphs.indexOf(graphs.find(x => x.vertices == points));        points.forEach((point, index) => {            for (const graph in graphs) {                if (!this.uppers[graph]) {                    this.uppers[graph] = [];                }                if (!this.sums[graph]) {                    this.sums[graph] = [];                }                if (graph < thisIndex) {                    this.uppers[graph].push(graphs[graph].vertices[index].y + 1);                    this.uppers[graph].push(graphs[graph].vertices[index].y + 1);                    this.sums[graph].push(0);                    this.sums[graph].push(0);                } else {                    this.uppers[graph].push(0);                    this.uppers[graph].push(0);                    this.sums[graph].push(graphs[graph].vertices[index].y + 1);                    this.sums[graph].push(graphs[graph].vertices[index].y + 1);                }            }        });    }}/** * This class exteds Path class to path bars. */class PathBar extends Path {    constructor(points, graphs) {        super(points);                this.pointers = [];        this.uppers = [];        this.bases = [];                        const amplitude = (points[1].x - points[0].x);        points.forEach(point => {            this.vertices.push(                point.x, -1,                point.x, point.y,                point.x + amplitude, point.y,                point.x + amplitude, -1            );        });                let j = 0;        let index = 0;        points.forEach(point => {            let i = index;            this.indices[j++] = i + 0;            this.indices[j++] = i + 1;            this.indices[j++] = i + 2;            this.indices[j++] = i + 2;            this.indices[j++] = i + 0;            this.indices[j++] = i + 3;            index += 4;        });                points.forEach((point, index) => {            this.pointers.push(index, index, index, index);        });                points.forEach((point, index) => {            this.bases.push(1, 0, 0, 1);        });                const thisIndex = graphs.indexOf(graphs.find(x => x.vertices == points));        points.forEach((point, index) => {            for (const graph in graphs) {                if (!this.uppers[graph]) {                    this.uppers[graph] = [];                }                if (graph < thisIndex) {                    this.uppers[graph].push(graphs[graph].vertices[index].y + 1);                    this.uppers[graph].push(graphs[graph].vertices[index].y + 1);                    this.uppers[graph].push(graphs[graph].vertices[index].y + 1);                    this.uppers[graph].push(graphs[graph].vertices[index].y + 1);                } else {                    this.uppers[graph].push(0);                    this.uppers[graph].push(0);                    this.uppers[graph].push(0);                    this.uppers[graph].push(0);                }            }        });    }}/** * This class exteds Path class to path lines. */class PathLine extends Path {    constructor(points) {        super(points);                this.indices = new Uint16Array(points.length * 6);        this.previouses = [];        this.nexts = [];        this.directions = [];                        points.forEach(point => {            this.vertices.push(point.x, point.y, point.x, point.y);        });                points.forEach((point, i, array) => {            if (i > 0) i--;            this.previouses.push(                array[i].x, array[i].y, array[i].x, array[i].y            );        });                points.forEach((point, i, array) => {            if (i < array.length - 1) i++;            this.nexts.push(                array[i].x, array[i].y, array[i].x, array[i].y            );        });                points.forEach(point => {            this.directions.push(-1, 1);        });                let j = 0;        let index = 0;        points.forEach(point => {            let i = index;            this.indices[j++] = i + 0;            this.indices[j++] = i + 1;            this.indices[j++] = i + 2;            this.indices[j++] = i + 2;            this.indices[j++] = i + 1;            this.indices[j++] = i + 3;            index += 2;        });    }}/** * This class is responsible for drawing the entire chart. */class ChartDrawer {    /**     * Creates an object for drawing charts.     */    constructor(chart, canvas, shadersPack, layout = null) {                        /**Chart object.*/        this.chart = chart;        /**Layout canvas.*/        this.canvas = layout;        /**GL Object.*/        this.gl = new GL(canvas);                /**Visible graphs area.*/        this.area = {            start: 0,            end: 1,            top: 1        };        /**The selection.*/        this.selection = {            index: -1,            points: [],            input: null,            value: null        }        /**Whether the chart needs to redraw.*/        this.redraw = true;        /**Whether draw layout or not.*/        this.layout = !!layout;        /**Calls every time when the drawe was recalculated.*/        this.onrecalculated = () => {};                /**Object that contains all animated properties.*/        this.animations = {            /**Describes graph transformations.*/            projection: new AnimationObject([1, 0, 0, 0, 1, 0, 0, 0, 1]),        };                /**Graph drawer objects.*/        this.graphDrawers = [];        /**Layout drawer object.*/        this.layoutDrawer = !this.layout ? null :            new LayoutDrawer(this, this.canvas, this.gl, shadersPack.layout);                        this.update();                for (const graph of chart.graphs) {            if (graph.type == "line") {                this.graphDrawers.push(new LineGraphDrawer(this, graph, this.gl, shadersPack.line));            } else if (graph.type == "bar") {                this.graphDrawers.push(new BarGraphDrawer(this, graph, this.gl, shadersPack.bar));            } else if (graph.type == "area") {                this.graphDrawers.push(new AreaGraphDrawer(this, graph, this.gl, shadersPack.area));            }        }        console.debug("ChartDrawer created", this);    }        /**     * Sets the start drawing point.     * @param {Number} percent The percentage(0-1) of drawing start point.     */    set start(value) {        if (value > 1) value = 1;        if (value < 0) value = 0;        this.area.start = value;        this.redraw = true;    }    /**     * Sets the end drawing point.     * @param {Number} percent The percentage(0-1) of drawing end point.     */    set end(value) {        if (value > 1) value = 1;        if (value < 0) value = 0;        this.area.end = value;        this.redraw = true;    }    /**     * Sets the postion of selection line.     * @param {Number} percent The percentage of selected point.     */    set select(value) {        const selection = value == null ? null :            (this.area.start + value / (1 / (this.area.end - this.area.start))) * 2 - 1;        this.selection.input = selection;        this.redraw = true;    }            /**     * Calculates chart values for drawing.     */    _calculate() {                let index = Math.round(this.area.start * this.chart.xAxis.length);        let previousDistance = Number.MAX_SAFE_INTEGER;        let goal = this.area.start * 2 - 1;                while (true) {            const vertex = this.graphDrawers[0].graph.vertices[index];            const distance = goal - vertex.x;            if (distance > 0) {                index++;            } else if (distance < 0) {                index--;            } else {                break;            }            if (Math.abs(previousDistance) > Math.abs(distance)) {                previousDistance = distance;            } else {                break;            }        }                const start = index;        let selectionIndex = -1;        let minSelectionDistance = Number.MAX_SAFE_INTEGER;        let maxY = -Number.MAX_SAFE_INTEGER;                goal = this.area.end * 2 - 1;        while (true) {                        if (index >= this.graphDrawers[0].graph.vertices.length) break;            const vertex = this.graphDrawers[0].graph.vertices[index];            if (vertex.x > goal) break;                        if (this.layout && this.selection.input != null) {                const distance = Math.abs(this.selection.input - vertex.x);                if (distance < minSelectionDistance) {                    minSelectionDistance = distance;                    selectionIndex = index;                }            }                        if (!this.chart.percentage) {                let sum = 0;                for (const drawer of this.graphDrawers) {                    if (!drawer.visible) continue;                    const graphVertex = drawer.graph.vertices[index];                    sum += graphVertex.y + 1;                    if (graphVertex.y > maxY) {                        maxY = graphVertex.y;                    }                }                                if (this.chart.stacked && (sum - 1) > maxY) {                    maxY = sum - 1;                }            } else {                maxY = 1;            }            index++;        }                this.area.top = maxY;                const zoomX = 1 / (this.area.end - this.area.start);        const zoomY = 2 / (this.area.top + 1);        const moveX = (1 - this.area.start - this.area.end) * zoomX;        const moveY = zoomY - 1;        const projection = [            zoomX, 0, 0,            0, zoomY, 0,            moveX, moveY, 1        ];        this.selection.index = selectionIndex;        this.selection.value = selectionIndex == -1 ? null :            this.graphDrawers[0].graph.vertices[selectionIndex];        this.selection.points = [];        if (selectionIndex != -1) {            for (const drawer of this.graphDrawers) {                this.selection.points.push(drawer.graph.vertices[selectionIndex].y * zoomY + moveY);            }        }                this.animations.projection.set(            projection,            this.animations.projection.modified ? ANIMATION_PERIOD / 2 : 0        );                this.onrecalculated();    }            /**     * Toggles or sets graph's visibility state by id.     * @param {Number} id Graph id.     * @param {Boolean} state Visibility state.     */    toggle(id, state = undefined) {        const drawer = this.graphDrawers[id];        if (state != drawer.visible) {            drawer.toggle();        }        this.redraw = true;    }    /**     * Updates sizes and colors.     */    update(backgroundColor, textColor, textFont, thickness) {        this.gl.resize();        if (backgroundColor) {            this.gl.background = backgroundColor;        }        if (thickness) {            for (const drawer of this.graphDrawers) {                if (drawer instanceof LineGraphDrawer) {                    drawer.thickness = thickness;                }            }        }        if (this.layout) {            this.canvas.width = this.canvas.clientWidth * window.devicePixelRatio;            this.canvas.height = this.canvas.clientHeight * window.devicePixelRatio;            if (textColor) {                this.layoutDrawer.color = textColor;                this.layoutDrawer.selectionDrawer.color = textColor;            }            if (textFont) {                this.layoutDrawer.font = textFont;            }        }        this.redraw = true;    }    /**     * Draws all charts.     */    draw() {        if (this.redraw) {            this._calculate();            this.gl.clear();            const projection = this.animations.projection.get();            for (const drawer of this.graphDrawers) {                drawer.draw(projection);            }            if (this.layout) {                this.layoutDrawer.draw(projection, this.selection);                                /*if (this.selection.value != null) {                    this.layoutDrawer.drawSelection(this.selection.value, this.graphDrawers[0].projection.get());                }*/            }            if (!this.graphDrawers.some(x => x.animating) &&                (!this.layout || !this.layoutDrawer.animating) &&                !Object.values(this.animations).some(x => x.inProgress)) {                this.redraw = false;            }        }    }    }/** * Abstract class from all graph drawers. */class GraphDrawer {    /**     * Creates an object for drawing graphs.     */    constructor(chartDrawer, graph, gl, shaders) {                if (new.target === GraphDrawer) {            throw new TypeError("Cannot construct an abstract class.");        }                        /**Shaders source*/        this.shaders = shaders;        /**Chart drawer object.*/        this.chartDrawer = chartDrawer;        /**The graph to draw.*/        this.graph = graph;        /**Path of graph vertices.*/        this.path = null;        /**GL Object.*/        this.gl = gl;        /**GL stack is.*/        this.stack = null;                /**Visibility state of the graph.*/        this.visible = true;        /**Cuts buffer for transfering the data to child objects.*/        this.cuts = {};                /**Object that contains all animated properties.*/        this.animations = {            /**Graph color*/            color: new AnimationObject(this.graph.color.alpha(0), this.graph.color, ANIMATION_PERIOD * 4)        };                        this.program = this._initializeProgram();                this._initializeAttributes();        console.debug("GraphDrawer created", this);    }        set color(value) {        this.animations.color.set(value, ANIMATION_PERIOD / 2);    }    get color() {        return this.animations.color.get();    }    get animating() {        return Object.values(this.animations).some(x => x.inProgress);    }            _initializeProgram() {        const vertex = new Shader(this.shaders[0], Shader.types.VERTEX);        const fragment = new Shader(this.shaders[1], Shader.types.FRAGMENT);        return this.gl.newProgram(new ShadersProgram(vertex, fragment));    }    _initializeAttributes() {        throw new Error("The method is not implemented!");    }            /**     * Toggles the graph visiblity.     */    toggle() {        this.color = new Color(this.color.r, this.color.g, this.color.b, +(!this.visible) * 255);        this.visible = !this.visible;    }    /**     * Draws the graph depending on current settings.     */    draw(projection) {                this.gl.program = this.program;        this.gl.stack = this.stack;        this.gl.uniforms.projection = projection;        this.gl.uniforms.color = this.color.toArray();                const start = (projection[0] - projection[6] - 1) / (2 * projection[0]);        const end = (projection[0] - projection[6] + 1) / (2 * projection[0]);        this.cuts.start = Math.round(start * this.graph.length);        this.cuts.end = Math.round(end * this.graph.length);                for (let i = 0; i < 2; i++) {            if (this.cuts.end < this.graph.length) this.cuts.end++;            if (this.cuts.start > 0) this.cuts.start--;        }    }    }/** * Class for drawing area stacked graphs. */class AreaGraphDrawer extends GraphDrawer {    constructor(chartDrawer, graph, gl, shaders) {        super(chartDrawer, graph, gl, shaders);    }        _initializeAttributes() {        this.path = new PathArea(this.graph.vertices, this.chartDrawer.chart.graphs);        this.stack = this.gl.newStack();        this.gl.attributes.position = this.path.vertices;        this.gl.attributes.base = this.path.bases;        for (const id in this.path.uppers) {            this.gl.attributes["upper" + id] = this.path.uppers[id];        }        for (const id in this.path.uppers) {            this.gl.attributes["sum" + id] = this.path.sums[id];        }    }    _initializeProgram() {        const vertex = new Shader(this.shaders[0], Shader.types.VERTEX);        const fragment = new Shader(this.shaders[1], Shader.types.FRAGMENT);        vertex.variables = {            count: this.chartDrawer.chart.graphs.length,            current: this.chartDrawer.graphDrawers.length        };        return this.gl.newProgram(new ShadersProgram(vertex, fragment));    }            /**     * Draws the graph depending on current settings.     */    draw(projection) {        super.draw(projection);        this.gl.uniforms.visible = this.chartDrawer.graphDrawers.map(x => (x.color.a / 255));        const count = this.cuts.end * 2;        const offset = this.cuts.start * 2;        this.gl.drawShape(count, offset);    }    }/** * Class for drawing bar graphs. */class BarGraphDrawer extends GraphDrawer {    constructor(chartDrawer, graph, gl, shaders) {        super(chartDrawer, graph, gl, shaders);    }        _initializeAttributes() {        this.path = new PathBar(this.graph.vertices, this.chartDrawer.chart.graphs);        this.stack = this.gl.newStack();        this.gl.indices = this.path.indices;        this.gl.attributes.position = this.path.vertices;        this.gl.attributes.pointer = this.path.pointers;        this.gl.attributes.base = this.path.bases;        for (const id in this.path.uppers) {            this.gl.attributes["upper" + id] = this.path.uppers[id];        }    }    _initializeProgram() {        const vertex = new Shader(this.shaders[0], Shader.types.VERTEX);        const fragment = new Shader(this.shaders[1], Shader.types.FRAGMENT);        vertex.variables = {            count: this.chartDrawer.chart.graphs.length,            current: this.chartDrawer.graphDrawers.length        };        return this.gl.newProgram(new ShadersProgram(vertex, fragment));    }            /**     * Draws the graph depending on current settings.     */    draw(projection) {        super.draw(projection);        this.gl.uniforms.selected = this.chartDrawer.selection.index;        this.gl.uniforms.visible = this.chartDrawer.graphDrawers.map(x => (x.color.a / 255));        const count = (this.cuts.end - 1) * 6;        const offset = this.cuts.start * 6;        this.gl.drawElements(count, offset);    }    }/** * Class for drawing line graphs. */class LineGraphDrawer extends GraphDrawer {    constructor(chartDrawer, graph, gl, shaders) {        super(chartDrawer, graph, gl, shaders);        this.thickness = 1;    }        _initializeAttributes() {        this.path = new PathLine(this.graph.vertices);        this.stack = this.gl.newStack();        this.gl.indices = this.path.indices;        this.gl.attributes.position = this.path.vertices;        this.gl.attributes.next = this.path.nexts;        this.gl.attributes.previous = this.path.previouses;        this.gl.attributes.direction = this.path.directions;    }            /**     * Draws the graph depending on current settings.     */    draw(projection) {        super.draw(projection);        this.gl.uniforms.aspect = this.gl.viewport.width / this.gl.viewport.height;        this.gl.uniforms.thickness = this.thickness / this.gl.canvas.height * Math.sqrt(window.devicePixelRatio);        const count = (this.cuts.end - 1) * 6;        const offset = this.cuts.start * 6;        this.gl.drawElements(count, offset);    }    }/** * Class for drawing chart layouts such as axises. */class LayoutDrawer {    /**     * Creates an object for drawing a layout.     * @param {Element} canvas The canvas for drawing layout.     */    constructor(chartDrawer, canvas, gl, shaders) {                        /**Shaders source*/        this.shaders = shaders;        /**Chart drawer object.*/        this.chartDrawer = chartDrawer;        /**Layout canvas.*/        this.canvas = canvas;        /**Layout canvas context.*/        this.context = canvas.getContext("2d");        /**GL Object.*/        this.gl = gl;        /**Shaders program for layout.*/        this.program = this._initializeProgram();                /**Amount of line to draw.*/        this.opacity = 192;        this.lineCount = 6;        this.dateCount = 7;        this.color = new Color();        this.font = "Helvetica";                /**Object that contains all animated properties.*/        this.animations = {            lineFade: new AnimationObject(64),            lineOffset: new AnimationObject(0),            dateFade: [],            dateOffset: new AnimationObject(0)        };                /**Selection drawer object.*/        this.selectionDrawer = new SelectionDrawer(chartDrawer, this.gl);                this._initializeAttributes();        console.debug("LayoutDrawer created", this);    }        get animating() {        return Object.values(this.animations).some(x => x.inProgress) ||            this.animations.dateFade.some(x => x.inProgress) || this.selectionDrawer.animating;    }            _initializeProgram() {        const vertex = new Shader(this.shaders[0], Shader.types.VERTEX);        const fragment = new Shader(this.shaders[1], Shader.types.FRAGMENT);        return this.gl.newProgram(new ShadersProgram(vertex, fragment));    }    _initializeAttributes() {        this.stack = this.gl.newStack();        let lines = [];        for (let i = 0; i < this.lineCount + 1; i++) {            lines.push(-1.1 * Math.pow(-1, i), 2 / this.lineCount * i - 1);            lines.push(1.1 * Math.pow(-1, i), 2 / this.lineCount * i - 1);        }        this.gl.attributes.position = lines;    }    /**     * Draws layout lines.     */    _drawLines(move, graphValue, graphMin, graphValue2, graphMin2) {        let projection = [            1, 0, 0,            0, 1, 0,            0, 0, 1        ];        let color = this.color.alpha(this.opacity);                this.gl.program = this.program;        this.gl.stack = this.stack;        this.gl.uniforms.projection = projection;        this.gl.uniforms.color = this.color.alpha(this.opacity).toArray();        this.gl.drawStrip(2);                projection[7] = move % (2 / this.lineCount);        if (projection[7] > (move % (1 / this.lineCount))) {            this.animations.lineFade.set(0, ANIMATION_PERIOD * 2);        } else {            this.animations.lineFade.set(this.opacity / 3, ANIMATION_PERIOD * 2);        }                projection[7] -=            (this.animations.lineFade.get() / this.opacity / 3) / this.lineCount;                this.gl.uniforms.projection = projection;        this.gl.uniforms.color = this.color            .alpha(this.animations.lineFade.get()).toArray();        this.gl.drawStrip((this.lineCount + 1) * 2, 1);                this._drawValues(            projection[7],            color.alpha(this.animations.lineFade.get()),            graphValue,            graphMin,            graphValue2,            graphMin2        );                projection[7] -= 1 / this.lineCount;        this.gl.uniforms.projection = projection;        this.gl.uniforms.color = this.color            .alpha(this.opacity / 3 - this.animations.lineFade.get()).toArray();        this.gl.drawStrip((this.lineCount + 1) * 2, 1);                this._drawValues(            projection[7],            this.color.alpha(this.opacity / 3 - this.animations.lineFade.get()),            graphValue,            graphMin,            graphValue2,            graphMin2        );    }    /**     * Draws y axis values.     */    _drawValues(y, color, graphValue, graphMin, graphValue2, graphMin2) {        const lineSpace = this.gl.canvas.height / this.lineCount;        const margin = 3 * window.devicePixelRatio;        let textColor = new Color(color);        textColor.a *= 2;        y = y * this.gl.canvas.height / 2 + margin;        this.context.fillStyle = textColor.toString();        this.context.font = lineSpace / 4 + "px " + this.font;        for (let i = 0; i < this.lineCount; i++) {            const textY = -y + i * lineSpace;            if (textY > this.gl.canvas.height) continue;            if (textY - lineSpace / 4 < 0) continue;            let label = (this.gl.canvas.height - textY) / this.gl.canvas.height * graphValue + graphMin;            label = format(label, this.chartDrawer.chart.percentage);            if (graphValue2) {                let color = new Color(this.chartDrawer.graphDrawers[0].color);                color.a *= textColor.a / (this.opacity / 3 * 2);                this.context.fillStyle = color.toString();            }            this.context.textAlign = "left";            this.context.fillText(label, 0, textY);            if (graphValue2) {                label = (this.gl.canvas.height - textY) / this.gl.canvas.height * graphValue2 + graphMin2;                label = format(label, this.chartDrawer.chart.percentage);                let color = new Color(this.chartDrawer.graphDrawers[1].color);                color.a *= textColor.a / (this.opacity / 3 * 2);                this.context.fillStyle = color.toString();                this.context.textAlign = "right";                this.context.fillText(label, this.gl.canvas.width, textY);            }        }                let label = format(graphMin, this.chartDrawer.chart.percentage);        if (graphValue2) {            let color = new Color(this.chartDrawer.graphDrawers[0].color);            color.a *= textColor.a / (this.opacity / 3 * 2);            this.context.fillStyle = color.toString();        }        this.context.textAlign = "left";        this.context.fillText(label, 0, this.gl.canvas.height - margin);        if (graphValue2) {            label = format(graphMin2, this.chartDrawer.chart.percentage);            let color = new Color(this.chartDrawer.graphDrawers[1].color);            color.a *= textColor.a / (this.opacity / 3 * 2);            this.context.fillStyle = color.toString();            this.context.textAlign = "right";            this.context.fillText(label, this.gl.canvas.width, this.gl.canvas.height - margin);        }        function format(number, isPercentage = false) {                        const percentage = isPercentage ? "%" : "";            const absolute = Math.abs(number);            if (absolute > 1000000000) {                return parseFloat((number / 1000000000).toFixed(2)) + "B";            } else if (absolute > 1000000) {                return parseFloat((number / 1000000).toFixed(2)) + "M";            } else if (absolute > 1000) {                return parseFloat((number / 1000).toFixed(1)) + "K";            } else {                return Math.round(number) + percentage;            }        }    }    /**     * Draws layout dates.     */    _drawDates(scale, chart, area) {        const dateSpace = this.canvas.width / (this.dateCount - 1);        const margin = ((this.canvas.height - this.gl.canvas.height) / 2);        const ratio = chart.size.x / this.canvas.width;        const y = this.canvas.height - margin / 1.5;        this.context.font = margin + "px " + this.font;        this.animations.dateOffset.set(-area.start * this.canvas.width, ANIMATION_PERIOD / 2);        this.context.fillStyle = this.color.toString();                for (let j = 1; j < scale ||            (this.animations.dateFade[j] && this.animations.dateFade[j].get()); j *= 2) {                        if (this.animations.dateFade[j] == undefined) {                this.animations.dateFade[j] = new AnimationObject(this.opacity);            }            if (scale > j && !this.animations.dateFade[j].inProgress && j != 1) {                this.animations.dateFade[j].set(this.opacity, ANIMATION_PERIOD);            } else if (!this.animations.dateFade[j].inProgress && j != 1) {                this.animations.dateFade[j].set(0, ANIMATION_PERIOD);            }                        this.context.fillStyle =                this.color.alpha(this.animations.dateFade[j].get()).toString();                        for (let i = (j == 1 ? 0 : 1); i < this.dateCount * j; i += (j == 1 ? 1 : 2)) {                let x = dateSpace * scale * i / j;                let label = Math.round(chart.offsets.x + x * ratio / scale);                x += this.animations.dateOffset.get() * scale;                                if (x > this.canvas.width) continue;                if ((x + margin * 4) < 0) continue;                                label = (new Date(label)).toString().split(' ')[1] + " " +                    (new Date(label)).toString().split(' ')[2];                                this.context.fillText(label, x, y);            }        }    }            /**     * Draws the layout.     */    draw(projection, selection) {        const move = projection[7];        const scaleY = projection[4];        const scaleX = projection[0];        if (!this.chartDrawer.chart.scaled) {            var graphValue = this.chartDrawer.chart.size.y / scaleY;            var graphMin = this.chartDrawer.chart.offsets.y;            if (this.chartDrawer.chart.stacked) {                graphMin = 0;            }        } else {            var graphValue = this.chartDrawer.chart.graphs[0].size.y / scaleY;            var graphValue2 = this.chartDrawer.chart.graphs[1].size.y / scaleY;            var graphMin = this.chartDrawer.chart.graphs[0].minY;            var graphMin2 = this.chartDrawer.chart.graphs[1].minY;        }        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);        this._drawLines(move, graphValue, graphMin, graphValue2, graphMin2);        this.selectionDrawer.draw(projection, selection);        this._drawDates(scaleX, this.chartDrawer.chart, this.chartDrawer.area);    }    }/** * Class for drawing the selection line and circles. */class SelectionDrawer {    constructor(chartDrawer, gl) {                        /**Chart drawer object.*/        this.chartDrawer = chartDrawer;        /**GL Object.*/        this.gl = gl;                /**Selection line color.*/        this.color = new Color();                this.animations = {            projection: new AnimationObject([1, 0, 0, 0, 1, 0, 0, 0, 1]),            points: new AnimationObject(Array.apply(null, Array(chartDrawer.chart.graphs.length)).map(x => 0))        };                this._initializeAttributes();    }        get animating() {        return Object.values(this.animations).some(x => x.inProgress);    }            _initializeAttributes() {        /**Selection stack id*/        this.stackLine = this.gl.newStack();        this.gl.attributes.position = [0, -1, 0, 1];        this.stackCircles = this.gl.newStack();        this.gl.attributes.position = [0, 0];    }    _drawSelection(projection) {                this.gl.stack = this.stackLine;        this.gl.uniforms.projection = projection;        this.gl.uniforms.color = this.color.alpha(128).toArray();        this.gl.drawStrip(2);    }    _drawCircles(points) {                this.gl.stack = this.stackCircles;        let circles = [];        let colors = [];        for (const i in points) {            circles.push(0, points[i]);            const colorArray = this.chartDrawer.graphDrawers[i].color.toArray();            colors.push(colorArray[0], colorArray[1], colorArray[2], colorArray[3]);        }        this.gl.attributes.position = circles;        this.gl.attributes.pointColor = colors;        this.gl.uniforms.circle = true;        this.gl.uniforms.windowSize = [this.gl.viewport.width, this.gl.viewport.height];        this.gl.uniforms.clearColor = this.gl.clearColor;        this.gl.drawPoints(points.length);        this.gl.uniforms.circle = false;    }            /**     * Draws the selection     */    draw(projection, selection) {        if (!selection.value) return        if (!this.chartDrawer.chart.stacked || this.chartDrawer.chart.percentage) {                        this.animations.projection.set([                1, 0, 0,                0, 1, 0,                selection.value.x * projection[0] + projection[6], 0, 1            ], ANIMATION_PERIOD / 4);            this.animations.points.set(selection.points, ANIMATION_PERIOD / 4);            projection = this.animations.projection.get();            const points = this.animations.points.get();            this._drawSelection(projection);            if (!this.chartDrawer.chart.percentage && points.length > 0) {                this._drawCircles(points);            }        }    }    }class ChartController {    /**     * Creates an interactive chart controller.     * @param {Element} selector Chart area selector element.     * @param {Element} leftDragger Area left side dragger element.     * @param {Element} rightDragger Area right side dragger element.     * @param {Function} onupdate Callback on controller's update.     */    constructor(selector, leftDragger, rightDragger, field) {                /**Chart area selector element.*/        this.selector = selector;        /**Chart drawing element.*/        this.field = field;        /**Border width style of the selector element.*/        this.borderWidth = parseInt(window.getComputedStyle(selector)["border-left-width"]) * 2;        /**Minimum width style of the selector element.*/        this.minWidth =            parseInt(window.getComputedStyle(selector)["min-width"]) + this.borderWidth;        /**Old element position for dragging.*/        this.positionOld = 0;        /**New element position for dragging.*/        this.positionNew = 0;        /**Callback on controller's update.*/        this.onupdate = () => {};        /**Callback on changed field selection.*/        this.onselect = () => {};                        leftDragger.onmousedown = (e) => {            this.startDrag(e, 1)        };        leftDragger.ontouchstart = (e) => {            this.startDrag(e, 1)        };        rightDragger.onmousedown = (e) => {            this.startDrag(e, 2)        };        rightDragger.ontouchstart = (e) => {            this.startDrag(e, 2)        };        selector.onmousedown = (e) => {            this.startDrag(e, 0)        };        selector.ontouchstart = (e) => {            this.startDrag(e, 0)        };        field.onmousemove = (e) => {            this.select(e, true);        };        field.onmouseleave = (e) => {            this.select(e, false);        };        field.ontouchstart = (e) => {            this.select(e, true);        };        field.ontouchmove = (e) => {            this.select(e, true);        };        field.ontouchend = (e) => {            this.select(e, false);        };                console.debug("ChartController created", this);    }    /**     * Updates current selection state and invokes callback.     * @param {Object} eventArgs Event arguments.     * @param {Bool} visible Whethe selection is visible now or not.     */    select(eventArgs, visible) {        if (!eventArgs.offsetX && eventArgs.touches && eventArgs.touches.length > 0) {            eventArgs.offsetX = eventArgs.targetTouches[0].pageX -                eventArgs.target.getBoundingClientRect().left;        }        eventArgs.preventDefault();        let percent = eventArgs.offsetX / this.field.clientWidth;        this.onselect(eventArgs.offsetX, percent, visible);    }    /**     * Starts element dragging.     * @param {Object} eventArgs Event arguments.     * @param {Number} type Type of dragging (0-2).     */    startDrag(eventArgs, type) {        eventArgs = eventArgs || window.event;        if (!eventArgs.clientX && eventArgs.touches) {            eventArgs.clientX = eventArgs.touches[0].clientX;        }        eventArgs.stopPropagation();        eventArgs.preventDefault();                this.positionOld = eventArgs.clientX;        document.onmouseup = (e) => {            this.stopDrag()        };        document.ontouchend = (e) => {            this.stopDrag()        };        document.onmousemove = (e) => {            this.drag(e, type)        };        document.ontouchmove = (e) => {            this.drag(e, type)        };    }    /**     * Performs element dragging.     * @param {Object} eventArgs Event arguments.     * @param {Number} type Type of dragging (0-2).     */    drag(eventArgs, type) {        eventArgs = eventArgs || window.event;        if (!eventArgs.clientX && eventArgs.touches) {            eventArgs.clientX = eventArgs.touches[0].clientX;        }        eventArgs.preventDefault();                this.positionNew = this.positionOld - eventArgs.clientX;        this.positionOld = eventArgs.clientX;                if (type === 0) {            let left = this.selector.offsetLeft - this.positionNew;            if (left < 0) left = 0;            this.selector.style.left = left + "px";        } else if (type === 1) {            let width = this.selector.clientWidth + this.positionNew;            let left = this.selector.offsetLeft - this.positionNew;            if (width < this.minWidth) {                left += width - this.minWidth;                width = this.minWidth;            }            if (left < 0) {                width -= -left;                left = 0;            }            this.selector.style.left = left + "px";            this.selector.style.width = width + "px";        } else if (type === 2) {            let width = this.selector.clientWidth - this.positionNew;            if (width + this.selector.offsetLeft + this.borderWidth >                this.selector.parentNode.clientWidth) {                width = this.selector.clientWidth;            }            this.selector.style.width = width + "px";        }        this.normalize();        this.update();    }    /**     * Stops element dragging.     */    stopDrag() {                document.onmouseup = null;        document.ontouchend = null;        document.onmousemove = null;        document.ontouchmove = null;    }    /**     * Makes sure that the element is inside boudary box if not normalizes.     */    normalize() {        if (parseInt(this.selector.style.left) < 0) {            this.selector.style.left = "0px";        }        if ((parseInt(this.selector.style.left) +                this.selector.clientWidth + this.borderWidth) >            this.selector.parentNode.clientWidth) {            this.selector.style.left = (this.selector.parentNode.clientWidth -                this.selector.clientWidth - this.borderWidth) + "px";        }    }    /**     * Updates current state of the controller and invokes callback.     */    update() {        let size = this.selector.parentNode.clientWidth;        let start = this.selector.offsetLeft / size;        let end = (this.selector.offsetLeft +            this.selector.clientWidth + this.borderWidth) / size;        this.onupdate(start, end);    }    get dragging() {        return !(document.onmouseup == null && document.ontouchend == null &&            document.onmousemove == null && document.ontouchmove == null);    }}const ANIMATION_PERIOD = 200;class ChartElement {    constructor(container, shadersPack) {        this.elements = {};        this.styles = {};        this.shaders = shadersPack;        this.elements.container = container;        this._initializeComponent();        this._windowWidth = window.innerWidth;                this.styles.text = "#000";        this.styles.background = "#FFF";        this.styles.font = "inherit";        this.styles.margin = "8px";        this.styles.dates = "24px";        this.styles.preview = "48px";        this.styles.lowlight = "0.1";        this.styles.border = "1px";        this.styles.select = "48px";        this._initializeStyle();    }        set chart(chart) {        this.chartData = new Chart(chart);        this.drawer = new ChartDrawer(            this.chartData,            this.elements.chart,            this.shaders,            this.elements.layout,        );        this.previewer = new ChartDrawer(            this.chartData,            this.elements.preview,            this.shaders        );        this.controller = new ChartController(            this.elements.select,            this.elements.draggerLeft,            this.elements.draggerRight,            this.elements.layout        );        const monthNames = ["January", "February", "March", "April", "May", "June",            "July", "August", "September", "October", "November", "December"        ];        this.controller.onupdate = (start, end) => {            this.elements.coverLeft.style.width = start * 100 + "%";            this.elements.coverRight.style.width = (1 - end) * 100 + "%";            this.drawer.start = start;            this.drawer.end = end;            const maxX = this.drawer.chart.size.x;            const minX = this.drawer.chart.xAxis[0];            const startDate = new Date(Math.round(start * maxX + minX));            const endDate = new Date(Math.round(end * maxX + minX));            const text = document.createTextNode(                startDate.getDate() + " " +                monthNames[startDate.getMonth()] + " " +                startDate.getFullYear() + " - " +                endDate.getDate() + " " +                monthNames[endDate.getMonth()] + " " +                endDate.getFullYear()            );            const child = this.elements.range.firstChild;            if (child)                this.elements.range.removeChild(child);            this.elements.range.appendChild(text);        };        this.controller.onselect = (x, value, visible) => {            if (visible) {                this.elements.tooltip.style.opacity = 1;                this.drawer.select = value;            } else {                this.elements.tooltip.style.opacity = 0;                this.drawer.select = null;            }            if (value < 0.5) {                this.elements.tooltip.style.left =                    x + parseInt(this.styles.margin) * 2 + "px";            } else {                this.elements.tooltip.style.left =                    (x - this.elements.tooltip.clientWidth - parseInt(this.styles.margin) * 2) + "px";            }        }        this.drawer.onrecalculated = () => {            if (this.drawer.selection.value == null) return;                        const index = this.drawer.selection.index;            let date = new Date(                this.drawer.chart.xAxis[index]            ).toString().split(" ");            date = date[0] + ", " + date[2] + " " + date[1] + " " + date[3];            this.elements.date.innerHTML = date;                        let values = this.elements.values.children;            for (let i = 0; i < values.length; i++) {                if (this.chartData.percentage) {                    let sum = this.drawer.graphDrawers.reduce((a, b) => {                        if (!b.visible) return a;                        return a + b.graph.points[index].y;                    }, 0);                    values[i].children[0].innerHTML = Math.round(                        this.drawer.chart.graphs[i].points[index].y / sum * 100                    ) + "%";                }                values[i].style.display = this.drawer.graphDrawers[i].visible ? "list-item" : "none";                values[i].children[values[i].children.length - 1].innerHTML =                    this.drawer.chart.graphs[i].points[index]                    .y.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");            }        }        this.controller.update();        this.elements.title.innerHTML = "";                for (const graphId in this.chartData.graphs) {            let container = document.createElement("div");            let percentage = document.createElement("div");            let name = document.createElement("div");            let value = document.createElement("div");            percentage.className = "chart-tooltip-values-percentage";            container.className = "chart-tooltip-values-value";            name.className = "chart-tooltip-values-value-value";            value.className = "chart-tooltip-values-value-name";            value.style.color = this.chartData.graphs[+graphId].color.toString();            name.innerHTML = this.chartData.graphs[+graphId].name;            container.style.fontSize = "0.85em";            container.float = "left";            percentage.style.float = "left";            percentage.style.width = "2.4em";            name.style.float = "left";            name.style.fontWeight = "normal";            value.style.float = "right";            if (this.chartData.percentage) {                container.appendChild(percentage);            }            container.appendChild(name);            container.appendChild(value);            this.elements.values.appendChild(container);        }                this.elements.buttons = [];        if (this.chartData.graphs.length <= 1) {            this.title = this.chartData.graphs[0].name;            return;        }        for (const graphId in this.chartData.graphs) {            let button = document.createElement("label");            let checkbox = document.createElement("input");            let icon = document.createElement("div");            let cover = document.createElement("div");            let name = document.createElement("span");            name.innerHTML = this.chartData.graphs[+graphId].name;            button.style.backgroundColor = this.chartData.graphs[+graphId].color;            button.style.borderColor = this.chartData.graphs[+graphId].color;            name.style.color = this.chartData.graphs[+graphId].color;            button.className = "chart-graph-button";            name.className = "chart-graph-button-name";            cover.className = "chart-graph-button-cover";            icon.className = "chart-graph-button-icon";            checkbox.type = "checkbox";            checkbox.checked = true;            checkbox.style.position = "fixed";            checkbox.style.opacity = "0";            button.appendChild(checkbox);            button.appendChild(icon);            button.appendChild(name);            button.appendChild(cover);            this.elements.graphs.appendChild(button);                        button.onclick = (e) => {                let visibleGraphs = this.drawer.graphDrawers.reduce((n, x) => {                    return n + (x.visible ? 1 : 0);                }, 0);                if (this.drawer.graphDrawers[+graphId].visible && visibleGraphs == 1) {                    return false;                }                this.drawer.toggle(+graphId, checkbox.checked);                this.previewer.toggle(+graphId, checkbox.checked);            }                        button.onmousedown = () => {                this.elements.buttons[+graphId].timeout = setTimeout(() => {                    toggleAll(this, +graphId)                }, 1000);            }            button.ontouchstart = () => {                this.elements.buttons[+graphId].timeout = setTimeout(() => {                    toggleAll(this, +graphId)                }, 1000);            }            button.onmouseup = () => {                clearTimeout(this.elements.buttons[+graphId].timeout);            }            button.ontouchend = () => {                clearTimeout(this.elements.buttons[+graphId].timeout);            }            this.elements.buttons.push(button);        }        function toggleAll(sender, except) {            sender.elements.buttons[except].firstChild.checked = true;            sender.drawer.toggle(except, true);            sender.previewer.toggle(except, true);            for (const id in sender.elements.buttons) {                if (id != except) {                    sender.elements.buttons[id].firstChild.checked = false;                    sender.elements.buttons[id].firstChild.checked = false;                    sender.drawer.toggle(id, false);                    sender.previewer.toggle(id, false);                }            }        }    }    set style(styles) {        this.styles.background = new Color(styles.background).toString() || this.styles.background;        this.styles.text = new Color(styles.text).toString() || this.styles.text;        this.styles.font = styles.font || this.styles.font;        this.styles.margin = styles.margin || this.styles.margin;        this.styles.dates = styles.dates || this.styles.dates;        this.styles.preview = styles.preview || this.styles.preview;        this.styles.lowlight = styles.lowlight || this.styles.lowlight;        this.styles.border = styles.border || this.styles.border;        this.styles.select = styles.select || this.styles.select;        this._initializeStyle();        this.drawer.update(            new Color(styles.background),            new Color(styles.text),            styles.font,            5        );        this.previewer.update(            new Color(styles.background),            new Color(styles.text),            styles.font,            2        );    }    set title(title) {        this.elements.title.innerHTML = title;    }    get title() {        return this.elements.title.innerHTML;    }            _initializeComponent() {                this.elements.header = document.createElement("div");        this.elements.title = document.createElement("span");        this.elements.range = document.createElement("span");        this.elements.header.className = "chart-header";        this.elements.title.className = "chart-title";        this.elements.range.className = "chart-range";        this.elements.header.appendChild(this.elements.title);        this.elements.header.appendChild(this.elements.range);                this.elements.tooltip = document.createElement("div");        this.elements.date = document.createElement("span");        this.elements.values = document.createElement("div");        this.elements.tooltip.className = "chart-tooltip";        this.elements.date.className = "chart-tooltip-date";        this.elements.values.className = "chart-tooltip-values";        this.elements.tooltip.appendChild(this.elements.date);        this.elements.tooltip.appendChild(this.elements.values);                this.elements.render = document.createElement("div");        this.elements.chart = document.createElement("canvas");        this.elements.layout = document.createElement("canvas");        this.elements.render.className = "chart-render";        this.elements.chart.className = "chart-render-chart";        this.elements.layout.className = "chart-render-layout";        this.elements.render.appendChild(this.elements.chart);        this.elements.render.appendChild(this.elements.layout);                this.elements.control = document.createElement("div");        this.elements.preview = document.createElement("canvas");        this.elements.select = document.createElement("div");        this.elements.draggerLeft = document.createElement("div");        this.elements.draggerRight = document.createElement("div");        this.elements.coverLeft = document.createElement("div");        this.elements.coverRight = document.createElement("div");        this.elements.control.className = "chart-control";        this.elements.preview.className = "chart-preview";        this.elements.select.className = "chart-select";        this.elements.draggerLeft.className = "chart-dragger chart-dragger-left";        this.elements.draggerRight.className = "chart-dragger chart-dragger-right";        this.elements.coverLeft.className = "chart-cover chart-cover-left";        this.elements.coverRight.className = "chart-cover chart-cover-right";        this.elements.control.appendChild(this.elements.preview);        this.elements.control.appendChild(this.elements.coverLeft);        this.elements.control.appendChild(this.elements.select);        this.elements.select.appendChild(this.elements.draggerLeft);        this.elements.select.appendChild(this.elements.draggerRight);        this.elements.control.appendChild(this.elements.coverRight);                this.elements.graphs = document.createElement("div");        this.elements.graphs.className = "chart-graphs";                this.elements.container.className += " chart-container";        this.elements.container.appendChild(this.elements.header);        this.elements.container.appendChild(this.elements.tooltip);        this.elements.container.appendChild(this.elements.render);        this.elements.container.appendChild(this.elements.control);        this.elements.container.appendChild(this.elements.graphs);    }    _initializeStyle() {        this.elements.container.style.font = this.styles.font;        this.elements.header.style.position = "relative";        this.elements.title.style.fontWeight = "bold";        this.elements.title.style.color = this.styles.text;        this.elements.title.style.marginLeft = parseInt(this.styles.margin) / 2 + "px";        this.elements.title.style.marginBottom = parseInt(this.styles.margin) + "px";        this.elements.range.style.float = "right";        this.elements.range.style.marginBottom = parseInt(this.styles.margin) + "px";        this.elements.range.style.fontSize = "0.9em";        this.elements.range.style.color = this.styles.text;        this.elements.range.style.zIndex = "100";        this.elements.tooltip.style.position = "absolute";        this.elements.tooltip.style.minWidth = "135.85px";        this.elements.tooltip.style.padding = parseInt(this.styles.margin) + "px";        this.elements.tooltip.style.fontSize = "14.3px";        this.elements.tooltip.style.borderRadius = parseInt(this.styles.margin) / 2 + "px";        this.elements.tooltip.style.boxShadow = "0px 0px 4px rgba(0, 0, 0, 0.4)";        this.elements.tooltip.style.backgroundColor = this.styles.background;        this.elements.tooltip.style.color = this.styles.text;        this.elements.tooltip.style.overflow = "hidden";        this.elements.tooltip.style.touchAction = "none";        this.elements.tooltip.style.pointerEvents = "none";        this.elements.tooltip.style.userAelect = "none";        this.elements.tooltip.style.zIndex = "100";        this.elements.tooltip.style.transition = "0.1s";        this.elements.tooltip.style.transitionProperty = "opacity";        this.elements.tooltip.style.opacity = "0";        this.elements.tooltip.style.fontWeight = "bold";        this.elements.render.style.position = "relative";        this.elements.render.style.width = "100%";        this.elements.render.style.height = "50vh";        this.elements.render.style.marginBottom = parseInt(this.styles.margin) + "px";        this.elements.chart.style.position = "absolute";        this.elements.chart.style.height = "calc(100% - " + parseInt(this.styles.dates) + "px)";        this.elements.chart.style.width = "100%";        this.elements.layout.style.position = "absolute";        this.elements.layout.style.height = "100%";        this.elements.layout.style.width = "100%";        this.elements.control.style.position = "relative";        this.elements.control.style.width = "100%";        this.elements.control.style.height = parseInt(this.styles.preview) + "px";        this.elements.control.style.touchAction = "none";        this.elements.control.style.userSelect = "none";        this.elements.control.style.marginBottom = parseInt(this.styles.margin) + "px";        this.elements.preview.style.position = "absolute";        this.elements.preview.style.width = "100%";        this.elements.preview.style.height = "100%";        this.elements.coverLeft.style.position = "absolute";        this.elements.coverLeft.style.left = "0";        this.elements.coverLeft.style.height = "100%";        this.elements.coverLeft.style.backgroundColor = this.styles.background;        this.elements.coverLeft.style.opacity = "0.6";        this.elements.coverLeft.style.userSelect = "none";        this.elements.coverLeft.style.filter = "brightness(" + (1 - this.styles.lowlight) + ")";        this.elements.coverRight.style.position = "absolute";        this.elements.coverRight.style.right = "0";        this.elements.coverRight.style.height = "100%";        this.elements.coverRight.style.backgroundColor = this.styles.background;        this.elements.coverRight.style.opacity = "0.6";        this.elements.coverRight.style.filter = "brightness(" + (1 - this.styles.lowlight) + ")";        this.elements.select.style.position = "absolute";        this.elements.select.style.height = "calc(100% - " + parseInt(this.styles.border) + "px * 2)";        this.elements.select.style.minWidth = parseInt(this.styles.select) + "px";        this.elements.select.style.maxWidth = "calc(100% - " - parseInt(this.styles.select) + "px * 8)";        this.elements.select.style.opacity = "0.2";        this.elements.select.style.border = parseInt(this.styles.border) + "px solid " + this.styles.text;        this.elements.select.style.borderLeftWidth = parseInt(this.styles.border) * 4 + "px";        this.elements.select.style.borderRightWidth = parseInt(this.styles.border) * 4 + "px";        this.elements.select.style.cursor = "grab";        this.elements.select.style.zIndex = "100";        this.elements.draggerLeft.style.position = "absolute";        this.elements.draggerLeft.style.left = "-18px";        this.elements.draggerLeft.style.height = "100%";        this.elements.draggerLeft.style.width = "24px";        this.elements.draggerLeft.style.cursor = "ew-resize";        this.elements.draggerLeft.style.zIndex = "100";        this.elements.draggerRight.style.position = "absolute";        this.elements.draggerRight.style.right = "-18px";        this.elements.draggerRight.style.height = "100%";        this.elements.draggerRight.style.width = "24px";        this.elements.draggerRight.style.cursor = "ew-resize";        this.elements.draggerRight.style.zIndex = "100";    }            update() {        if (window.innerWidth != this._windowWidth) {            this.elements.select.style.left = "0px";            this.elements.select.style.width = "0px";        }        this.drawer.update();        this.previewer.update();        this.controller.update();        this._windowWidth = window.innerWidth;    }    render() {        this.drawer.draw();        this.previewer.draw();    }    }